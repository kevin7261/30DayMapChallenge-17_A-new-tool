/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.134.1
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
import{a as wt}from"./chunk-IXYLEDPQ.js";import{a as C}from"./chunk-26456K5W.js";import{a as kt}from"./chunk-GCWYQAXJ.js";import{a as Ct}from"./chunk-QND5YPLT.js";import{b as dt,c as _t,d as N}from"./chunk-UHBRQJNJ.js";import{d as ht}from"./chunk-KWW52NRT.js";import{a as M}from"./chunk-XNSUDY5I.js";import{a as s,c as lt,d as it,f as pt}from"./chunk-HMXGNDLA.js";import{a as E}from"./chunk-V7XA5C77.js";import{a as g}from"./chunk-U7V5VQ2T.js";import{e as v}from"./chunk-NVZ5L4JK.js";var yt=new s,vt=new s,Et=new s,Mt=new s,Nt=new s,Rt=new s(1,1,1),Pt=Math.cos,At=Math.sin;function x(t){t=t??pt.EMPTY_OBJECT;let e=t.radii??Rt,i=t.innerRadii??e,n=t.minimumClock??0,a=t.maximumClock??E.TWO_PI,o=t.minimumCone??0,r=t.maximumCone??E.PI,m=Math.round(t.stackPartitions??64),c=Math.round(t.slicePartitions??64),u=t.vertexFormat??C.DEFAULT;if(c<3)throw new g("options.slicePartitions cannot be less than three.");if(m<3)throw new g("options.stackPartitions cannot be less than three.");this._radii=s.clone(e),this._innerRadii=s.clone(i),this._minimumClock=n,this._maximumClock=a,this._minimumCone=o,this._maximumCone=r,this._stackPartitions=m,this._slicePartitions=c,this._vertexFormat=C.clone(u),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidGeometry"}x.packedLength=2*s.packedLength+C.packedLength+7,x.pack=function(t,e,i){if(!v(t))throw new g("value is required");if(!v(e))throw new g("array is required");return i=i??0,s.pack(t._radii,e,i),i+=s.packedLength,s.pack(t._innerRadii,e,i),i+=s.packedLength,C.pack(t._vertexFormat,e,i),i+=C.packedLength,e[i++]=t._minimumClock,e[i++]=t._maximumClock,e[i++]=t._minimumCone,e[i++]=t._maximumCone,e[i++]=t._stackPartitions,e[i++]=t._slicePartitions,e[i]=t._offsetAttribute??-1,e};var ot,bt=new s,xt=new s,Ot=new C,L={radii:bt,innerRadii:xt,vertexFormat:Ot,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};x.unpack=function(t,e,i){if(!v(t))throw new g("array is required");e=e??0;let n=s.unpack(t,e,bt);e+=s.packedLength;let a=s.unpack(t,e,xt);e+=s.packedLength;let o=C.unpack(t,e,Ot);e+=C.packedLength;let r=t[e++],m=t[e++],c=t[e++],u=t[e++],l=t[e++],f=t[e++],p=t[e];return v(i)?(i._radii=s.clone(n,i._radii),i._innerRadii=s.clone(a,i._innerRadii),i._vertexFormat=C.clone(o,i._vertexFormat),i._minimumClock=r,i._maximumClock=m,i._minimumCone=c,i._maximumCone=u,i._stackPartitions=l,i._slicePartitions=f,i._offsetAttribute=-1===p?void 0:p,i):(L.minimumClock=r,L.maximumClock=m,L.minimumCone=c,L.maximumCone=u,L.stackPartitions=l,L.slicePartitions=f,L.offsetAttribute=-1===p?void 0:p,new x(L))},x.createGeometry=function(t){let e=t._radii;if(e.x<=0||e.y<=0||e.z<=0)return;let i=t._innerRadii;if(i.x<=0||i.y<=0||i.z<=0)return;let n=t._minimumClock,a=t._maximumClock,o=t._minimumCone,r=t._maximumCone,m=t._vertexFormat,c=t._slicePartitions+1,u=t._stackPartitions+1;c=Math.round(c*Math.abs(a-n)/E.TWO_PI),u=Math.round(u*Math.abs(r-o)/E.PI),c<2&&(c=2),u<2&&(u=2);let l,f,p=0,h=[o],_=[n];for(l=0;l<u;l++)h.push(o+l*(r-o)/(u-1));for(h.push(r),f=0;f<c;f++)_.push(n+f*(a-n)/(c-1));_.push(a);let d=h.length,k=_.length,x=0,C=1,w=i.x!==e.x||i.y!==e.y||i.z!==e.z,A=!1,y=!1,P=!1;w&&(C=2,o>0&&(A=!0,x+=c-1),r<Math.PI&&(y=!0,x+=c-1),(a-n)%E.TWO_PI?(P=!0,x+=2*(u-1)+1):x+=1);let g=k*d*C,b=new Float64Array(3*g),L=new Array(g).fill(!1),T=new Array(g).fill(!1),F=c*u*C,O=6*(F+x+1-(c+u)*C),I=kt.createTypedArray(F,O),D=m.normal?new Float32Array(3*g):void 0,z=m.tangent?new Float32Array(3*g):void 0,R=m.bitangent?new Float32Array(3*g):void 0,j=m.st?new Float32Array(2*g):void 0,U=new Array(d),W=new Array(d);for(l=0;l<d;l++)U[l]=At(h[l]),W[l]=Pt(h[l]);let G=new Array(k),Y=new Array(k);for(f=0;f<k;f++)Y[f]=Pt(_[f]),G[f]=At(_[f]);for(l=0;l<d;l++)for(f=0;f<k;f++)b[p++]=e.x*U[l]*Y[f],b[p++]=e.y*U[l]*G[f],b[p++]=e.z*W[l];let S,X,J,K,Q=g/2;if(w)for(l=0;l<d;l++)for(f=0;f<k;f++)b[p++]=i.x*U[l]*Y[f],b[p++]=i.y*U[l]*G[f],b[p++]=i.z*W[l],L[Q]=!0,l>0&&l!==d-1&&0!==f&&f!==k-1&&(T[Q]=!0),Q++;for(p=0,l=1;l<d-2;l++)for(S=l*k,X=(l+1)*k,f=1;f<k-2;f++)I[p++]=X+f,I[p++]=X+f+1,I[p++]=S+f+1,I[p++]=X+f,I[p++]=S+f+1,I[p++]=S+f;if(w){let t=d*k;for(l=1;l<d-2;l++)for(S=t+l*k,X=t+(l+1)*k,f=1;f<k-2;f++)I[p++]=X+f,I[p++]=S+f,I[p++]=S+f+1,I[p++]=X+f,I[p++]=S+f+1,I[p++]=X+f+1}if(w){if(A)for(K=d*k,l=1;l<k-2;l++)I[p++]=l,I[p++]=l+1,I[p++]=K+l+1,I[p++]=l,I[p++]=K+l+1,I[p++]=K+l;if(y)for(J=d*k-k,K=d*k*C-k,l=1;l<k-2;l++)I[p++]=J+l+1,I[p++]=J+l,I[p++]=K+l,I[p++]=J+l+1,I[p++]=K+l,I[p++]=K+l+1}if(P){for(l=1;l<d-2;l++)K=k*d+k*l,J=k*l,I[p++]=K,I[p++]=J+k,I[p++]=J,I[p++]=K,I[p++]=K+k,I[p++]=J+k;for(l=1;l<d-2;l++)K=k*d+k*(l+1)-1,J=k*(l+1)-1,I[p++]=J+k,I[p++]=K,I[p++]=J,I[p++]=J+k,I[p++]=K+k,I[p++]=K}let B=new Ct;m.position&&(B.position=new N({componentDatatype:M.DOUBLE,componentsPerAttribute:3,values:b}));let V,q=0,H=0,Z=0,$=0,tt=g/2,et=it.fromCartesian3(e),nt=it.fromCartesian3(i);if(m.st||m.normal||m.tangent||m.bitangent){for(l=0;l<g;l++){V=L[l]?nt:et;let t=s.fromArray(b,3*l,yt),e=V.geodeticSurfaceNormal(t,vt);if(T[l]&&s.negate(e,e),m.st){let t=lt.negate(e,Nt);j[q++]=Math.atan2(t.y,t.x)/E.TWO_PI+.5,j[q++]=Math.asin(e.z)/Math.PI+.5}if(m.normal&&(D[H++]=e.x,D[H++]=e.y,D[H++]=e.z),m.tangent||m.bitangent){let t,i=Et,n=0;if(L[l]&&(n=tt),t=!A&&l>=n&&l<n+2*k?s.UNIT_X:s.UNIT_Z,s.cross(t,e,i),s.normalize(i,i),m.tangent&&(z[Z++]=i.x,z[Z++]=i.y,z[Z++]=i.z),m.bitangent){let t=s.cross(e,i,Mt);s.normalize(t,t),R[$++]=t.x,R[$++]=t.y,R[$++]=t.z}}}m.st&&(B.st=new N({componentDatatype:M.FLOAT,componentsPerAttribute:2,values:j})),m.normal&&(B.normal=new N({componentDatatype:M.FLOAT,componentsPerAttribute:3,values:D})),m.tangent&&(B.tangent=new N({componentDatatype:M.FLOAT,componentsPerAttribute:3,values:z})),m.bitangent&&(B.bitangent=new N({componentDatatype:M.FLOAT,componentsPerAttribute:3,values:R}))}if(v(t._offsetAttribute)){let e=b.length,i=t._offsetAttribute===wt.NONE?0:1,n=new Uint8Array(e/3).fill(i);B.applyOffset=new N({componentDatatype:M.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new _t({attributes:B,indices:I,primitiveType:dt.TRIANGLES,boundingSphere:ht.fromEllipsoid(et),offsetAttribute:t._offsetAttribute})},x.getUnitEllipsoid=function(){return v(ot)||(ot=x.createGeometry(new x({radii:new s(1,1,1),vertexFormat:C.POSITION_ONLY}))),ot};var Kt=x;export{Kt as a};